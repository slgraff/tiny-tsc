{	QPDEFS3.Tdescription:	xneed to do:		xto improve:		xPROBLEMS:	is (polymer (x) true) a state or a relation of x to itself????notes:			x=== PLEASE FORMAT this doc with NewCentury Font, tab stops 4, 12 pt, Margin 100, Reduced 73 %.=== ANNOTATION: #### = HACK, ???? = QUESTION, **** = UNTESTED, $$$$ = TO-DO, &&&& = NOTECHANGES:	950417	jp2:	updated}{ Intended to work with messages stored in slots in the episodes of an envisionment.	THESE RULES ARE A "HACK" used primarily to test the envisionment engine.	Mostly, they do nothing of significance, generally causing the episodes they build	to be "killed."	WHAT'S NEEDED is to use them as templates for rules of substance and generality.}\ ______________________________________________________________________ PHYS.PROCESSCOMMENT: this rule needs to explicity define amount.of and temperature rather than have nested	sentences\ =============================={	EVAPORATION	description:		x	example input:		x	example output:	x	notes:				x}c:	EVAPORATION	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	analogies			boiling	ifActors			( ( container ( *container ) true )							( liquid ( *fluid ) true )							( gas ( *environment ) true ) )	ifRelates			( ( contains ( *container *fluid ) true )							( abuts ( *fluid *environment ) true ) )	ifStates			( ( greater.than ( temperature ( *fluid ) temperature ( *environment ) ) true ) )	thenStates			( ( decreasing ( amount.of ( *fluid ) ) true )						  ( decreasing ( temperature ( *fluid ) ) true ) )	then.expect			( ( empty ( *container ) true ) )COMMENT;\ =============================={	HEAT.TRANS.STARTUP	description:		x	example input:		x	example output:	x	notes:				x}c:	HEAT.TRANS.STARTUP	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	ifToDo				( ( increase ( *t1 ) true ) )	ifRelates			( ( abuts ( *heat.sink *convective.medium ) true )						  ( abuts ( *heat.source *convective.medium ) true ) )	ifStates				( ( active ( *heat.source ) false ) )	thenStates			( ( active ( *heat.source ) true )							( greater.than ( *t1 *t2 ) true )							( increasing ( *t1 ) true )							( decreasing ( *t1 ) false )							( decreasing ( *t2 ) false )							( same ( *t1 ) false )							( same ( *t2 ) false )							( equal ( *t1 room.temp ) false ) )\	then.forget			( ( active ( *heat.source ) false ) )\ without additional heat input\ =============================={	CONVECT.HEAT.TRANS.NOTDRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONVECT.HEAT.TRANS.NOTDRIVEN	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	ifNotStates			( ( increasing ( *t2 ) true ) )	ifRelates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	ifStates				( ( greater.than ( *t1 *t2 ) true )							( active ( *heat.source ) false )							( decreasing ( *t1 ) true ) )	thenStates			( ( increasing ( *t2 ) true ) )\ with additional heat input, not enough\ =============================={	CONVECT.HEAT.TRANS.UNDERDRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONVECT.HEAT.TRANS.UNDERDRIVEN	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	ifNotStates			( ( increasing ( *t2 ) true ) )	ifRelates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	ifStates				( ( greater.than ( *t1 *t2 ) true )							( decreasing ( *t1 ) true ) )	thenStates			( ( increasing ( *t2 ) true ) )\ with additional heat input, just enough\ =============================={	CONVECT.HEAT.TRANS.DRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONVECT.HEAT.TRANS.DRIVEN	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	ifNotStates			( ( increasing ( *t2 ) true ) )	ifRelates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	ifStates				( ( greater.than ( *t1 *t2 ) true )							( same ( *t1 ) true ) )	thenStates			( ( increasing ( *t1 ) false )							( same ( *t1 ) true )							( decreasing ( *t1 ) false )							( increasing ( *t2 ) true ) )\ with additional heat input, too much\	( equal ( *t1 room.temp ) false ) ---- is a HACK--bad, very bad!	####\	this rule will probably always fire, even when overdriven.2 should\ =============================={	CONVECT.HEAT.TRANS.OVERDRIVEN.1	description:		x	example input:		x	example output:	x	notes:				x}c:	CONVECT.HEAT.TRANS.OVERDRIVEN.1	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	ifNotStates			( ( increasing ( *t2 ) true ) )	ifRelates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	ifStates				( ( greater.than ( *t1 *t2 ) true )							( increasing ( *t1 ) true ) )	thenStates			( ( increasing ( *t2 ) true ) )\ =============================={	CONVECT.HEAT.TRANS.OVERDRIVEN.2	description:		x	example input:		x	example output:	x	notes:				should not (greater.than (x y) true) be a relation ????}c:	CONVECT.HEAT.TRANS.OVERDRIVEN.2	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	ifNotStates			( ( increasing ( *t2 ) true ) )	ifRelates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	ifStates			( ( active ( *heat.source ) true )							( greater.than ( *t1 *t2 ) true )							( increasing ( *t1 ) true ) )	ifToDo				( ( increase ( *heat.source ) true ) )	thenStates			( ( increasing ( *t2 ) true ) )\ without additional heat input\ =============================={	CONDUCT.HEAT.TRANS.NOTDRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONDUCT.HEAT.TRANS.NOTDRIVEN	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( source.temp.sensor ( *t1 ) true )							( sink.temp.sensor ( *t2 ) true ) )	ifRelates			( ( abuts ( *heat.sink *heat.source ) true ) )	ifStates			( ( greater.than ( *t1 *t2 ) true ) )	thenStates			( ( decreasing ( *t2 ) false )							( increasing ( *t2 ) true )							( decreasing ( *t1 ) true )							( increasing ( *t1 ) false )							( active ( *heat.source ) false ) )\ with additional heat input, not enough\ =============================={	CONDUCT.HEAT.TRANS.UNDERDRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONDUCT.HEAT.TRANS.UNDERDRIVEN	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( source.temp.sensor ( *t1 ) true )							( sink.temp.sensor ( *t2 ) true ) )	ifRelates			( ( abuts ( *heat.sink *heat.source ) true ) )	ifStates			( ( greater.than ( *t1 *t2 ) true ) )	thenStates			( ( decreasing ( *t2 ) false )							( increasing ( *t2 ) true )							( decreasing ( *t1 ) true )							( increasing ( *t1 ) false )							( active ( *heat.source ) true ) )\ with additional heat input, just enough\ =============================={	CONDUCT.HEAT.TRANS.DRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONDUCT.HEAT.TRANS.DRIVEN	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( source.temp.sensor ( *t1 ) true )							( sink.temp.sensor ( *t2 ) true ) )	ifRelates			( ( abuts ( *heat.sink *heat.source ) true ) )	ifStates			( ( greater.than ( *t1 *t2 ) true ) )	thenStates			( ( decreasing ( *t2 ) false )							( increasing ( *t2 ) true )							( decreasing ( *t1 ) false )							( increasing ( *t1 ) false )							( active ( *heat.source ) true ) )\ with additional heat input, over enough\ =============================={	CONDUCT.HEAT.TRANS.OVERDRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONDUCT.HEAT.TRANS.OVERDRIVEN	subOf				phys.process	instanceOf			process.rule	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( source.temp.sensor ( *t1 ) true )							( sink.temp.sensor ( *t2 ) true ) )	ifRelates			( ( abuts ( *heat.sink *heat.source ) true ) )	ifStates			( ( greater.than ( *t1 *t2 ) true ) )	thenStates			( ( decreasing ( *t2 ) false )							( increasing ( *t2 ) true )							( decreasing ( *t1 ) false )							( increasing ( *t1 ) true )							( active ( *heat.source ) true ) )\ =============================={	EXOTHERM.reaction.1	description:		x	example input:		x	example output:	x	notes:				x}c:	EXOTHERM.reaction.1	subOf				phys.process chem.process	instanceOf			process.rule	spec.of				exotherm.reaction	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.sink.sensor ( *t2 ) true )							( heat.source.sensor ( *t1 ) true ) )	ifRelates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	ifStates			( ( reactive ( *heat.sink ) true )							( polymer ( *heat.sink ) true )							( increasing ( *t2 ) true ) )	ifNotStates	( ( accelerating ( *T2 ) true ) )			\ DJW ADDED	ifToDo				( ( increase ( *t1 ) true ) )	thenStates			( ( accelerating ( *t2 ) true ) )\ =============================={	EXOTHERM.reaction.2	description:		x	example input:		x	example output:	x	notes:				x}c:	EXOTHERM.reaction.2	subOf				phys.process chem.process	instanceOf			process.rule	spec.of				exotherm.reaction	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.sink.sensor ( *t2 ) true )							( heat.source.sensor ( *t1 ) true ) )	ifRelates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	ifStates			( ( reactive ( *heat.sink ) true )							( polymer ( *heat.sink ) true )							( accelerating ( *t2 ) true )							( increasing ( *t2 ) true ) )	ifToDo				( ( decrease ( *t1 ) true ) )	thenStates			( ( accelerating ( *t2 ) false )							( reactive ( *heat.sink ) false ) )\ reference to "burnt" should be built and used in "common sense" rules for domain\	a mere exotherm with continued external energy input does not imply "burnt" for\	all materials\ =============================={	EXOTHERM.reaction.3	description:		x	example input:		x	example output:	x	notes:				x}c:	EXOTHERM.reaction.3	subOf				phys.process chem.process	instanceOf			process.rule	spec.of				exotherm.reaction	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.sink.sensor ( *t2 ) true )							( heat.source.sensor ( *t1 ) true ) )	ifRelates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	ifStates			( ( reactive ( *heat.sink ) true )							( polymer ( *heat.sink ) true )							( accelerating ( *t2 ) true )							( increasing ( *t2 ) true ) )	ifToDo				( ( increase ( *t1 ) true ) )	thenStates			( ( reactive ( *heat.sink ) false )							( burnt ( *heat.sink ) true ) )\ =============================={	EXOTHERM.reaction.4	description:		x	example input:		x	example output:	x	notes:				x}c:	EXOTHERM.reaction.4·	subOf				phys.process chem.process	instanceOf			process.rule	spec.of				exotherm.reaction	myCreator			jp2	ifActors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.sink.sensor ( *t2 ) true )							( heat.source.sensor ( *t1 ) true ) )	ifRelates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	ifStates			( ( reactive ( *heat.sink ) true )							( polymer ( *heat.sink ) true )							( accelerating ( *t2 ) true )							( increasing ( *t2 ) true ) )	ifToDo				( ( same ( *t1 ) true ) )	thenStates			( ( accelerating ( *t2 ) true )							( reactive ( *heat.sink ) false )							( burnt ( *heat.sink ) true ) )